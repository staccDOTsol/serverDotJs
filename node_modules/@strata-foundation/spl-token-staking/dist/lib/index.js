"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SplTokenStaking = void 0;
const anchor = __importStar(require("@project-serum/anchor"));
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const spl_utils_1 = require("@strata-foundation/spl-utils");
const bn_js_1 = __importDefault(require("bn.js"));
const spl_token_staking_1 = require("./generated/spl-token-staking");
__exportStar(require("./generated/spl-token-staking"), exports);
class SplTokenStaking extends spl_utils_1.AnchorSdk {
    constructor(provider, program) {
        super({ provider, program });
    }
    get defaults() {
        return {
            periodUnit: spl_token_staking_1.PeriodUnit.SECOND,
            period: 5,
            targetMintDecimals: 9,
            rewardPercentPerPeriodPerLockupPeriod: 4294967295, // 100%
        };
    }
    getPeriod(staking, unixTs) {
        const multiplier = staking.period * SplTokenStaking.PERIOD_MULTIPLIERS[Object.keys(staking.periodUnit)[0]];
        return Math.floor((unixTs - staking.createdTimestamp.toNumber()) / multiplier);
    }
    getTotalTargetSupply(targetMint, staking) {
        try {
            return (targetMint.supply.toNumber() +
                staking.targetAmountUnredeemed.toNumber() +
                staking.targetAmountPerPeriod.toNumber() *
                    (this.getPeriod(staking, Date.now() / 1000) -
                        this.getPeriod(staking, staking.lastCalculatedTimestamp.toNumber())));
        }
        catch (e) {
            console.log("Get total target supply failed, logging params");
            console.log(targetMint.supply.toString(10));
            console.log(staking.targetAmountUnredeemed.toString(10));
            console.log(staking.targetAmountPerPeriod.toString(10));
            throw e;
        }
    }
    getTotalTargetSupplyFromKey(tokenStaking) {
        return __awaiter(this, void 0, void 0, function* () {
            const staking = yield this.account.tokenStakingV0.fetch(tokenStaking);
            const mintInfo = yield (0, spl_utils_1.getMintInfo)(this.provider, staking.targetMint);
            // @ts-ignore
            return this.getTotalTargetSupply(mintInfo, staking);
        });
    }
    createTokenStakingInstructions({ authority, payer = this.wallet.publicKey, baseMint, periodUnit, period, rewardPercentPerPeriodPerLockupPeriod, targetMintDecimals, targetMint }) {
        return __awaiter(this, void 0, void 0, function* () {
            const programId = this.programId;
            const provider = this.provider;
            const instructions = [];
            const signers = [];
            let shouldCreateMint = false;
            if (!targetMint) {
                const targetMintKeypair = anchor.web3.Keypair.generate();
                targetMint = targetMintKeypair.publicKey;
                signers.push(targetMintKeypair);
                shouldCreateMint = true;
            }
            const [targetMintAuthorityRes, targetMintAuthorityBumpSeed] = yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("target-authority", "utf-8"), targetMint.toBuffer()], programId);
            const targetMintAuthority = targetMintAuthorityRes;
            if (shouldCreateMint) {
                const tokenInstructions = yield (0, spl_utils_1.createMintInstructions)(provider, targetMintAuthority, targetMint, targetMintDecimals);
                instructions.push(...tokenInstructions);
            }
            const [tokenStaking, bumpSeed] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("token-staking", "utf-8"),
                baseMint.toBuffer(),
                targetMint.toBuffer(),
            ], programId);
            instructions.push(yield this.instruction.initializeTokenStakingV0(
            // @ts-ignore
            {
                periodUnit,
                period,
                rewardPercentPerPeriodPerLockupPeriod,
                bumpSeed,
                targetMintAuthorityBumpSeed,
                authority,
            }, {
                accounts: {
                    payer: payer,
                    baseMint: baseMint,
                    targetMint: targetMint,
                    tokenStaking,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                },
            }));
            return {
                output: {
                    targetMint: targetMint,
                    tokenStaking,
                    tokenStakingBumpSeed: bumpSeed,
                },
                instructions,
                signers,
            };
        });
    }
    createTokenStaking(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { output: { tokenStaking }, instructions, signers, } = yield this.createTokenStakingInstructions(args);
            yield this.sendInstructions(instructions, signers);
            return tokenStaking;
        });
    }
    stakeInstructions({ tokenStaking, amount, voucherNumber, lockupPeriods, owner = this.wallet.publicKey, payer = this.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenStakingAccount = yield this.program.account.tokenStakingV0.fetch(tokenStaking);
            let voucherNumberToUse = voucherNumber || 0;
            const getVoucher = () => {
                const pad = Buffer.alloc(2);
                new bn_js_1.default(voucherNumberToUse, 16, 'le').toBuffer().copy(pad);
                return web3_js_1.PublicKey.findProgramAddress([Buffer.from("stake-voucher", "utf-8"), owner.toBuffer(), tokenStaking.toBuffer(), pad], this.programId);
            };
            const getVoucherAccount = () => __awaiter(this, void 0, void 0, function* () {
                return this.provider.connection.getAccountInfo((yield getVoucher())[0]);
            });
            if (!voucherNumber) {
                // Find an empty voucher account
                while (yield getVoucherAccount()) {
                    voucherNumberToUse++;
                }
            }
            else {
                voucherNumberToUse = voucherNumber;
            }
            const [stakingVoucher, bumpSeed] = yield getVoucher();
            const [baseHolding, holdingBumpSeed] = yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("holding", "utf-8"), stakingVoucher.toBuffer()], this.programId);
            const [baseHoldingAuthority, holdingAuthorityBumpSeed] = yield web3_js_1.PublicKey.findProgramAddress([Buffer.from("holding-authority", "utf-8"), baseHolding.toBuffer()], this.programId);
            const ataBumpSeed = (yield web3_js_1.PublicKey.findProgramAddress([owner.toBuffer(), spl_token_1.TOKEN_PROGRAM_ID.toBuffer(), tokenStakingAccount.targetMint.toBuffer()], spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID))[1];
            const purchaseAccount = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, tokenStakingAccount.baseMint, owner);
            const instructions = [];
            const [stakingInfo, stakingInfoBumpSeed] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("stake-info", "utf-8"),
                owner.toBuffer(),
                tokenStaking.toBuffer()
            ], this.programId);
            const stakingInfoAccount = yield this.program.account.stakingInfoV0.fetchNullable(stakingInfo);
            if (!stakingInfoAccount) {
                instructions.push(yield this.instruction.initializeStakingInfoV0(stakingInfoBumpSeed, {
                    accounts: {
                        payer,
                        tokenStaking,
                        stakingInfo,
                        owner,
                        systemProgram: web3_js_1.SystemProgram.programId,
                        rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                        clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                    }
                }));
            }
            instructions.push(yield this.instruction.stakeV0({
                voucherNumber: voucherNumberToUse,
                baseAmount: amount,
                lockupPeriods,
                bumpSeed,
                holdingAuthorityBumpSeed,
                holdingBumpSeed,
                ataBumpSeed
            }, {
                accounts: {
                    stakingInfo,
                    payer,
                    baseMint: tokenStakingAccount.baseMint,
                    tokenStaking: tokenStaking,
                    owner,
                    stakingVoucher,
                    baseHoldingAuthority,
                    baseHolding,
                    purchaseAccount,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    systemProgram: web3_js_1.SystemProgram.programId,
                    rent: web3_js_1.SYSVAR_RENT_PUBKEY,
                    clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                },
            }));
            return {
                instructions,
                signers: [],
                output: {
                    stakingVoucher,
                },
            };
        });
    }
    stake(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { output: { stakingVoucher }, instructions, signers, } = yield this.stakeInstructions(args);
            yield this.sendInstructions(instructions, signers);
            return stakingVoucher;
        });
    }
    collectInstructions({ tokenStaking, stakingVoucher, payer = this.wallet.publicKey, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const staking = yield this.account.tokenStakingV0.fetch(tokenStaking);
            const voucher = yield this.account.stakingVoucherV0.fetch(stakingVoucher);
            const destination = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, staking.targetMint, voucher.owner);
            const destinationAcct = yield this.provider.connection.getAccountInfo(destination);
            const instructions = [];
            if (!destinationAcct) {
                instructions.push(spl_token_1.Token.createAssociatedTokenAccountInstruction(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, staking.targetMint, destination, voucher.owner, payer));
            }
            const mintAuthority = yield web3_js_1.PublicKey.createProgramAddress([
                Buffer.from("target-authority", "utf-8"),
                staking.targetMint.toBuffer(),
                new bn_js_1.default(staking.targetMintAuthorityBumpSeed).toBuffer(),
            ], this.programId);
            const [stakingInfo] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("stake-info", "utf-8"),
                voucher.owner.toBuffer(),
                tokenStaking.toBuffer()
            ], this.programId);
            instructions.push(yield this.instruction.collectRewardsV0({
                accounts: {
                    tokenStaking,
                    stakingInfo,
                    stakingVoucher,
                    destination,
                    targetMint: staking.targetMint,
                    mintAuthority,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                },
            }));
            return {
                instructions,
                signers: [],
                output: {
                    destination,
                },
            };
        });
    }
    collect(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { output: { destination }, instructions, signers, } = yield this.collectInstructions(args);
            yield this.sendInstructions(instructions, signers);
            return destination;
        });
    }
    unstakeInstructions({ tokenStaking, stakingVoucher, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const staking = yield this.account.tokenStakingV0.fetch(tokenStaking);
            const voucher = yield this.account.stakingVoucherV0.fetch(stakingVoucher);
            const destination = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, staking.baseMint, voucher.owner);
            const baseHolding = yield web3_js_1.PublicKey.createProgramAddress([
                Buffer.from("holding", "utf-8"),
                stakingVoucher.toBuffer(),
                new bn_js_1.default(voucher.holdingBumpSeed).toBuffer(),
            ], this.programId);
            const baseHoldingAuthority = yield web3_js_1.PublicKey.createProgramAddress([
                Buffer.from("holding-authority", "utf-8"),
                baseHolding.toBuffer(),
                new bn_js_1.default(voucher.holdingAuthorityBumpSeed).toBuffer(),
            ], this.programId);
            const [stakingInfo] = yield web3_js_1.PublicKey.findProgramAddress([
                Buffer.from("stake-info", "utf-8"),
                voucher.owner.toBuffer(),
                tokenStaking.toBuffer()
            ], this.programId);
            return {
                signers: [],
                output: null,
                instructions: [
                    yield this.instruction.unstakeV0({
                        accounts: {
                            tokenStaking,
                            stakingInfo,
                            stakingVoucher,
                            owner: voucher.owner,
                            destination,
                            baseHolding,
                            baseHoldingAuthority,
                            clock: web3_js_1.SYSVAR_CLOCK_PUBKEY,
                            tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                            systemProgram: web3_js_1.SystemProgram.programId,
                        },
                    }),
                ],
            };
        });
    }
    unstake(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const { instructions, signers } = yield this.unstakeInstructions(args);
            yield this.sendInstructions(instructions, signers);
        });
    }
}
exports.SplTokenStaking = SplTokenStaking;
SplTokenStaking.PERIOD_MULTIPLIERS = {
    second: 1,
    minute: 60,
    hour: 60 * 60,
    day: 60 * 60 * 24,
    year: 60 * 60 * 24 * 365,
};
//# sourceMappingURL=index.js.map