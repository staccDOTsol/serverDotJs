"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRemainingAccountsForCreateClass = exports.generateRemainingAccountsGivenPermissivenessToUse = void 0;
const pda_1 = require("../utils/pda");
async function generateRemainingAccountsGivenPermissivenessToUse(args) {
    const { permissivenessToUse, program, tokenMint, parentMint, parent, parentIndex, metadataUpdateAuthority, } = args;
    const remainingAccounts = [];
    if (permissivenessToUse.tokenHolder) {
        const tokenAccount = (await (0, pda_1.getAtaForMint)(tokenMint, program.provider.wallet.publicKey))[0];
        const tokenHolder = program.provider.wallet.publicKey;
        remainingAccounts.push({
            pubkey: tokenAccount,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: tokenHolder,
            isWritable: false,
            isSigner: true,
        });
    }
    else if (permissivenessToUse.parentTokenHolder) {
        const parentToken = (await (0, pda_1.getAtaForMint)(parentMint, program.provider.wallet.publicKey))[0];
        const parentHolder = program.provider.wallet.publicKey;
        const parentClass = parent || (await (0, pda_1.getItemPDA)(parentMint, parentIndex))[0];
        remainingAccounts.push({
            pubkey: parentToken,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: parentHolder,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: parentClass,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: parentMint,
            isWritable: false,
            isSigner: false,
        });
    }
    else if (permissivenessToUse.updateAuthority || !permissivenessToUse) {
        remainingAccounts.push({
            pubkey: metadataUpdateAuthority || program.provider.wallet.publicKey,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: await (0, pda_1.getMetadata)(tokenMint),
            isWritable: false,
            isSigner: false,
        });
    }
    return remainingAccounts;
}
exports.generateRemainingAccountsGivenPermissivenessToUse = generateRemainingAccountsGivenPermissivenessToUse;
// Creating a class uses the parent (if set) update permissivenesses and as such
// produces slightly different remainingAccounts. So this method is used instead for class creation.
// If parent is set, defaults to using update authority as a permissiveness to make the new token class.
async function generateRemainingAccountsForCreateClass(args) {
    const { permissivenessToUse, program, tokenMint, parentMint, parent, metadataUpdateAuthority, parentOfParentClassMint, parentOfParentClassIndex, parentOfParentClass, parentUpdateAuthority, } = args;
    const remainingAccounts = [];
    if (!parent || !parentMint) {
        remainingAccounts.push({
            pubkey: metadataUpdateAuthority || program.provider.wallet.publicKey,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: await (0, pda_1.getMetadata)(tokenMint),
            isWritable: false,
            isSigner: false,
        });
    }
    else if (permissivenessToUse.tokenHolder) {
        const tokenAccount = (await (0, pda_1.getAtaForMint)(parentMint, program.provider.wallet.publicKey))[0];
        const tokenHolder = program.provider.wallet.publicKey;
        remainingAccounts.push({
            pubkey: tokenAccount,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: tokenHolder,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: parentMint,
            isWritable: false,
            isSigner: false,
        });
    }
    else if (permissivenessToUse.parentTokenHolder) {
        const parentToken = (await (0, pda_1.getAtaForMint)(parentOfParentClassMint, program.provider.wallet.publicKey))[0];
        const parentHolder = program.provider.wallet.publicKey;
        const parentClass = parentOfParentClass ||
            (await (0, pda_1.getItemPDA)(parentOfParentClassMint, parentOfParentClassIndex))[0];
        remainingAccounts.push({
            pubkey: parentToken,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: parentHolder,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: parentClass,
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: parentOfParentClassMint,
            isWritable: false,
            isSigner: false,
        });
    }
    else if (permissivenessToUse.updateAuthority) {
        remainingAccounts.push({
            pubkey: parentUpdateAuthority || program.provider.wallet.publicKey,
            isWritable: false,
            isSigner: true,
        });
        remainingAccounts.push({
            pubkey: await (0, pda_1.getMetadata)(parentMint),
            isWritable: false,
            isSigner: false,
        });
        remainingAccounts.push({
            pubkey: parentMint,
            isWritable: false,
            isSigner: false,
        });
    }
    return remainingAccounts;
}
exports.generateRemainingAccountsForCreateClass = generateRemainingAccountsForCreateClass;
