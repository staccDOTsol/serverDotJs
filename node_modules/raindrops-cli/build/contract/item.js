"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getItemProgram = exports.ItemProgram = exports.ItemClassWrapper = void 0;
const anchor_1 = require("@project-serum/anchor");
const web3_js_1 = require("@solana/web3.js");
const nodewallet_1 = __importDefault(require("@project-serum/anchor/dist/cjs/nodewallet"));
const programIds_1 = require("../constants/programIds");
const item_1 = require("../state/item");
const pda_1 = require("../utils/pda");
const common_1 = require("./common");
const loglevel_1 = __importDefault(require("loglevel"));
const connection_1 = require("../utils/connection");
const spl_token_1 = require("@solana/spl-token");
const transactions_1 = require("../utils/transactions");
function convertNumsToBNs(data) {
    var _a, _b;
    if (data.itemClassData) {
        if (data.itemClassData.settings.stakingWarmUpDuration)
            data.itemClassData.settings.stakingWarmUpDuration = new anchor_1.BN(data.itemClassData.settings.stakingWarmUpDuration);
        if (data.itemClassData.settings.stakingCooldownDuration)
            data.itemClassData.settings.stakingCooldownDuration = new anchor_1.BN(data.itemClassData.settings.stakingCooldownDuration);
        (_a = data.itemClassData.config.components) === null || _a === void 0 ? void 0 : _a.forEach((k) => {
            if (k.timeToBuild != null) {
                k.timeToBuild = new anchor_1.BN(k.timeToBuild);
            }
        });
        (_b = data.itemClassData.config.usages) === null || _b === void 0 ? void 0 : _b.forEach((k) => {
            if (k.validation != null && k.validation != undefined) {
                k.validation.key = new anchor_1.web3.PublicKey(k.validation.key);
                k.validation.code = new anchor_1.BN(k.validation.code);
            }
            if (k.callback != null && k.callback != undefined) {
                k.callback.key = new anchor_1.web3.PublicKey(k.callback.key);
                k.callback.code = new anchor_1.BN(k.callback.code);
            }
            let u = k.itemClassType.consumable;
            if (u) {
                if (u.maxUses != null)
                    u.maxUses = new anchor_1.BN(u.maxUses);
                if (u.maxPlayersPerUse != null)
                    u.maxPlayersPerUse = new anchor_1.BN(u.maxPlayersPerUse);
                if (u.warmupDuration != null)
                    u.warmupDuration = new anchor_1.BN(u.warmupDuration);
                if (u.cooldownDuration != null) {
                    u.cooldownDuration = new anchor_1.BN(u.cooldownDuration);
                }
            }
            u = k.itemClassType.wearable;
            if (u) {
                if (u.limitPerPart) {
                    u.limitPerPart = new anchor_1.BN(u.limitPerPart);
                }
            }
        });
    }
}
class ItemClassWrapper {
    constructor(args) {
        this.program = args.program;
        this.key = args.key;
        this.object = args.object;
        this.data = args.data;
    }
}
exports.ItemClassWrapper = ItemClassWrapper;
class ItemProgram {
    constructor(args) {
        this.id = args.id;
        this.program = args.program;
    }
    async fetchItemClass(mint, index) {
        let itemClass = (await (0, pda_1.getItemPDA)(mint, index))[0];
        // Need a manual deserializer due to our hack we had to do.
        let itemClassObj = await this.program.provider.connection.getAccountInfo(itemClass);
        const ic = (0, item_1.decodeItemClass)(itemClassObj.data);
        ic.program = this.program;
        return new ItemClassWrapper({
            program: this,
            key: itemClass,
            data: itemClassObj.data,
            object: ic,
        });
    }
    async createItemEscrow(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.buildPermissivenessToUse,
            tokenMint: accounts.itemClassMint,
            parentMint: accounts.parentMint,
            parentIndex: args.parentClassIndex,
            parent: accounts.parentMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentMint, args.parentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemClassMint, args.classIndex))[0];
        const [itemEscrow, itemEscrowBump] = await (0, pda_1.getItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            craftEscrowIndex: args.craftEscrowIndex,
            classIndex: args.classIndex,
            newItemMint: accounts.newItemMint,
            newItemToken: accounts.newItemToken ||
                (await (0, pda_1.getAtaForMint)(accounts.newItemMint, this.program.provider.wallet.publicKey))[0],
            payer: this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        });
        args.craftBump = itemEscrowBump;
        await this.program.rpc.createItemEscrow(args, {
            accounts: {
                itemClass: itemClassKey,
                itemClassMetadata: await (0, pda_1.getMetadata)(accounts.itemClassMint),
                newItemMint: accounts.newItemMint,
                newItemMetadata: await (0, pda_1.getMetadata)(accounts.newItemMint),
                newItemEdition: await (0, pda_1.getEdition)(accounts.newItemMint),
                itemEscrow,
                newItemToken: accounts.newItemToken ||
                    (await (0, pda_1.getAtaForMint)(accounts.newItemMint, this.program.provider.wallet.publicKey))[0],
                newItemTokenHolder: accounts.newItemTokenHolder || this.program.provider.wallet.publicKey,
                payer: this.program.provider.wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
    }
    async completeItemEscrowBuildPhase(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.buildPermissivenessToUse,
            tokenMint: accounts.itemClassMint,
            parentMint: accounts.parentMint,
            parentIndex: args.parentClassIndex,
            parent: accounts.parentMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentMint, args.parentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemClassMint, args.classIndex))[0];
        const [newItem, newItemBump] = await (0, pda_1.getItemPDA)(accounts.newItemMint, args.newItemIndex);
        args.newItemBump = newItemBump;
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: accounts.newItemMint,
            newItemToken: accounts.newItemToken ||
                (await (0, pda_1.getAtaForMint)(accounts.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
            payer: args.originator || this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        await this.program.rpc.completeItemEscrowBuildPhase(args, {
            accounts: {
                itemClass: itemClassKey,
                itemEscrow,
                newItem,
                newItemMint: accounts.newItemMint,
                newItemMetadata: await (0, pda_1.getMetadata)(accounts.newItemMint),
                newItemEdition: await (0, pda_1.getEdition)(accounts.newItemMint),
                newItemToken: accounts.newItemToken ||
                    (await (0, pda_1.getAtaForMint)(accounts.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
                newItemTokenHolder: accounts.newItemTokenHolder ||
                    args.originator ||
                    this.program.provider.wallet.publicKey,
                payer: this.program.provider.wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: programIds_1.TOKEN_PROGRAM_ID,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
    }
    async deactivateItemEscrow(args, _accounts, _additionalArgs) {
        args.newItemToken =
            args.newItemToken ||
                (await (0, pda_1.getAtaForMint)(args.newItemMint, this.program.provider.wallet.publicKey))[0];
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: args.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            newItemToken: args.newItemToken,
            payer: this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        await this.program.rpc.deactivateItemEscrow(args, {
            accounts: {
                itemEscrow,
                originator: this.program.provider.wallet.publicKey,
            },
        });
    }
    async updateValidForUseIfWarmupPassed(args, _accounts = {}, _additionalArgs = {}) {
        const itemActivationMarker = (await (0, pda_1.getItemActivationMarker)({
            itemMint: args.itemMint,
            index: args.index,
            usageIndex: new anchor_1.BN(args.usageIndex),
            amount: args.amount,
        }))[0];
        await this.program.rpc.updateValidForUseIfWarmupPassed(args, {
            accounts: {
                item: (await (0, pda_1.getItemPDA)(args.itemMint, args.index))[0],
                itemClass: (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0],
                itemActivationMarker,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
            },
        });
    }
    async addCraftItemToEscrow(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.buildPermissivenessToUse,
            tokenMint: accounts.itemClassMint,
            parentMint: accounts.parentMint,
            parentIndex: args.parentClassIndex,
            parent: accounts.parentMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentMint, args.parentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemClassMint, args.classIndex))[0];
        const craftItemTokenAccount = (await (0, pda_1.getAtaForMint)(accounts.craftItemTokenMint, this.program.provider.wallet.publicKey))[0];
        const [craftItemEscrow, itemEscrowBump] = await (0, pda_1.getCraftItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftIndex: args.craftItemIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            craftItemMint: accounts.craftItemTokenMint,
            craftItemToken: craftItemTokenAccount,
            payer: this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            amountToContributeFromThisContributor: args.amountToContributeFromThisContributor,
            componentScope: args.componentScope,
        });
        const [craftItemCounter, craftBump] = await (0, pda_1.getCraftItemCounter)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftItemIndex: args.craftItemIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            craftItemMint: accounts.craftItemTokenMint,
            componentScope: args.componentScope,
        });
        args.tokenBump = itemEscrowBump;
        args.craftItemCounterBump = craftBump;
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            newItemToken: accounts.newItemToken ||
                (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
            payer: args.originator || this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        const craftItem = (await (0, pda_1.getItemPDA)(accounts.craftItemTokenMint, args.craftItemIndex))[0];
        const craftItemObj = await this.program.account.item.fetch(craftItem);
        const instructions = [], signers = [];
        const craftItemTransferAuthority = anchor_1.web3.Keypair.generate();
        signers.push(craftItemTransferAuthority);
        instructions.push(spl_token_1.Token.createApproveInstruction(programIds_1.TOKEN_PROGRAM_ID, craftItemTokenAccount, craftItemTransferAuthority.publicKey, this.program.provider.wallet.publicKey, [], args.amountToContributeFromThisContributor.toNumber()));
        instructions.push(await this.program.instruction.addCraftItemToEscrow(args, {
            accounts: {
                itemClass: itemClassKey,
                itemEscrow,
                craftItemCounter,
                newItemToken: accounts.newItemToken ||
                    (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
                newItemTokenHolder: accounts.newItemTokenHolder ||
                    args.originator ||
                    this.program.provider.wallet.publicKey,
                craftItemTokenAccountEscrow: craftItemEscrow,
                craftItemTokenMint: accounts.craftItemTokenMint,
                craftItemTokenAccount,
                craftItem,
                craftItemClass: craftItemObj.parent,
                craftItemTransferAuthority: craftItemTransferAuthority.publicKey,
                payer: this.program.provider.wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: programIds_1.TOKEN_PROGRAM_ID,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        }));
        instructions.push(spl_token_1.Token.createRevokeInstruction(programIds_1.TOKEN_PROGRAM_ID, craftItemTokenAccount, this.program.provider.wallet.publicKey, []));
        await (0, transactions_1.sendTransactionWithRetry)(this.program.provider.connection, this.program.provider.wallet, instructions, signers);
    }
    async removeCraftItemFromEscrow(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.buildPermissivenessToUse,
            tokenMint: accounts.itemClassMint,
            parentMint: accounts.parentMint,
            parentIndex: args.parentClassIndex,
            parent: accounts.parentMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentMint, args.parentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemClassMint, args.classIndex))[0];
        const craftItemTokenAccount = (await (0, pda_1.getAtaForMint)(args.craftItemTokenMint, this.program.provider.wallet.publicKey))[0];
        const [craftItemEscrow, itemEscrowBump] = await (0, pda_1.getCraftItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftIndex: args.craftItemIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            craftItemMint: args.craftItemTokenMint,
            craftItemToken: craftItemTokenAccount,
            payer: this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            amountToContributeFromThisContributor: args.amountContributedFromThisContributor,
            componentScope: args.componentScope,
        });
        const [craftItemCounter, craftBump] = await (0, pda_1.getCraftItemCounter)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftItemIndex: args.craftItemIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            craftItemMint: args.craftItemTokenMint,
            componentScope: args.componentScope,
        });
        args.tokenBump = itemEscrowBump;
        args.craftItemCounterBump = craftBump;
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            newItemToken: accounts.newItemToken ||
                (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
            payer: args.originator || this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        await this.program.rpc.removeCraftItemFromEscrow(args, {
            accounts: {
                itemClass: itemClassKey,
                itemEscrow,
                craftItemCounter,
                newItemToken: accounts.newItemToken ||
                    (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
                newItemTokenHolder: accounts.newItemTokenHolder ||
                    args.originator ||
                    this.program.provider.wallet.publicKey,
                craftItemTokenAccountEscrow: craftItemEscrow,
                craftItemTokenAccount,
                craftItem: (await (0, pda_1.getItemPDA)(args.craftItemTokenMint, args.craftItemIndex))[0],
                craftItemClass: (await (0, pda_1.getItemPDA)(args.craftItemClassMint, args.craftItemClassIndex))[0],
                receiver: this.program.provider.wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: programIds_1.TOKEN_PROGRAM_ID,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
    }
    async beginItemActivation(args, accounts, _additionalArgs = {}) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.usagePermissivenessToUse,
            tokenMint: accounts.itemMint,
            parentMint: args.itemClassMint,
            parentIndex: args.classIndex,
            parent: (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0],
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0];
        const [itemActivationMarker, bump] = await (0, pda_1.getItemActivationMarker)({
            itemMint: accounts.itemMint,
            index: args.index,
            usageIndex: new anchor_1.BN(args.usageIndex),
            amount: args.amount,
        });
        args.itemActivationBump = bump;
        const instructions = [], signers = [];
        const itemTransferAuthority = accounts.itemTransferAuthority || anchor_1.web3.Keypair.generate();
        if (accounts.itemAccount.equals((await (0, pda_1.getAtaForMint)(accounts.itemMint, this.program.provider.wallet.publicKey))[0])) {
            signers.push(itemTransferAuthority);
            instructions.push(spl_token_1.Token.createApproveInstruction(programIds_1.TOKEN_PROGRAM_ID, accounts.itemAccount, itemTransferAuthority.publicKey, this.program.provider.wallet.publicKey, [], args.amount.toNumber()));
        }
        const itemKey = (await (0, pda_1.getItemPDA)(accounts.itemMint, args.index))[0];
        const itemClass = await this.fetchItemClass(args.itemClassMint, args.classIndex);
        instructions.push(this.program.instruction.beginItemActivation(args, {
            accounts: {
                itemClass: itemClassKey,
                itemMint: accounts.itemMint,
                item: itemKey,
                itemAccount: accounts.itemAccount,
                itemTransferAuthority: itemTransferAuthority.publicKey,
                itemActivationMarker,
                payer: this.program.provider.wallet.publicKey,
                playerProgram: programIds_1.PLAYER_ID,
                systemProgram: web3_js_1.SystemProgram.programId,
                tokenProgram: programIds_1.TOKEN_PROGRAM_ID,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
                validationProgram: itemClass.object.itemClassData.config.usages[args.usageIndex].validation
                    ? new anchor_1.web3.PublicKey(itemClass.object.itemClassData.config.usages[args.usageIndex].validation.key)
                    : web3_js_1.SystemProgram.programId,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        }));
        if (accounts.itemAccount.equals((await (0, pda_1.getAtaForMint)(accounts.itemMint, this.program.provider.wallet.publicKey))[0])) {
            instructions.push(spl_token_1.Token.createRevokeInstruction(programIds_1.TOKEN_PROGRAM_ID, accounts.itemAccount, this.program.provider.wallet.publicKey, []));
        }
        await (0, transactions_1.sendTransactionWithRetry)(this.program.provider.connection, this.program.provider.wallet, instructions, signers);
    }
    async endItemActivation(args, accounts, _additionalArgs = {}) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.usagePermissivenessToUse,
            tokenMint: args.itemMint,
            parentMint: args.itemClassMint,
            parentIndex: args.classIndex,
            parent: (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0],
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0];
        const itemActivationMarker = (await (0, pda_1.getItemActivationMarker)({
            itemMint: args.itemMint,
            index: args.index,
            usageIndex: new anchor_1.BN(args.usageIndex),
            amount: args.amount,
        }))[0];
        const itemKey = (await (0, pda_1.getItemPDA)(args.itemMint, args.index))[0];
        await this.program.rpc.endItemActivation(args, {
            accounts: {
                itemClass: itemClassKey,
                item: itemKey,
                itemActivationMarker,
                receiver: accounts.originator || this.program.provider.wallet.publicKey,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
    }
    async drainItemEscrow(args, accounts, _additionalArgs = {}) {
        const itemClassKey = (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0];
        if (!args.newItemToken) {
            args.newItemToken = (await (0, pda_1.getAtaForMint)(args.newItemMint, this.program.provider.wallet.publicKey))[0];
        }
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: args.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            newItemToken: args.newItemToken,
            payer: this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        await this.program.rpc.drainItemEscrow(args, {
            accounts: {
                itemEscrow,
                originator: accounts.originator,
            },
        });
    }
    async startItemEscrowBuildPhase(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
            permissivenessToUse: args.buildPermissivenessToUse,
            tokenMint: accounts.itemClassMint,
            parentMint: accounts.parentMint,
            parentIndex: args.parentClassIndex,
            parent: accounts.parentMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentMint, args.parentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            program: this.program,
        });
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemClassMint, args.classIndex))[0];
        const itemEscrow = (await (0, pda_1.getItemEscrow)({
            itemClassMint: accounts.itemClassMint,
            classIndex: args.classIndex,
            craftEscrowIndex: args.craftEscrowIndex,
            newItemMint: args.newItemMint,
            newItemToken: accounts.newItemToken ||
                (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
            payer: args.originator || this.program.provider.wallet.publicKey,
            amountToMake: args.amountToMake,
            componentScope: args.componentScope,
        }))[0];
        await this.program.rpc.startItemEscrowBuildPhase(args, {
            accounts: {
                itemClass: itemClassKey,
                itemEscrow,
                newItemToken: accounts.newItemToken ||
                    (await (0, pda_1.getAtaForMint)(args.newItemMint, args.originator || this.program.provider.wallet.publicKey))[0],
                newItemTokenHolder: accounts.newItemTokenHolder ||
                    args.originator ||
                    this.program.provider.wallet.publicKey,
                clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
    }
    async createItemClass(args, accounts, additionalArgs) {
        const remainingAccounts = await (0, common_1.generateRemainingAccountsForCreateClass)({
            permissivenessToUse: args.updatePermissivenessToUse,
            tokenMint: accounts.itemMint,
            parentMint: accounts.parentMint,
            parent: accounts.parent,
            parentOfParentClassMint: accounts.parentOfParentClassMint,
            parentOfParentClassIndex: args.parentOfParentClassIndex,
            parentOfParentClass: args.parentOfParentClassIndex && accounts.parentOfParentClassMint
                ? (await (0, pda_1.getItemPDA)(accounts.parentOfParentClassMint, args.parentOfParentClassIndex))[0]
                : null,
            metadataUpdateAuthority: accounts.metadataUpdateAuthority,
            parentUpdateAuthority: accounts.parentUpdateAuthority,
            program: this.program,
        });
        convertNumsToBNs(args);
        const [itemClassKey, itemClassBump] = await (0, pda_1.getItemPDA)(accounts.itemMint, args.classIndex);
        args.itemClassBump = itemClassBump;
        await this.program.rpc.createItemClass(args, {
            accounts: {
                itemClass: itemClassKey,
                itemMint: accounts.itemMint,
                metadata: await (0, pda_1.getMetadata)(accounts.itemMint),
                edition: await (0, pda_1.getEdition)(accounts.itemMint),
                parent: accounts.parent || itemClassKey,
                payer: this.program.provider.wallet.publicKey,
                systemProgram: web3_js_1.SystemProgram.programId,
                rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
        return itemClassKey;
    }
    async updateItem(args, _accounts, additionalArgs) {
        const itemClassKey = (await (0, pda_1.getItemPDA)(args.itemClassMint, args.classIndex))[0];
        const itemKey = (await (0, pda_1.getItemPDA)(args.itemMint, args.index))[0];
        await this.program.rpc.updateItem(args, {
            accounts: {
                itemClass: itemClassKey,
                item: itemKey,
            },
        });
        return itemClassKey;
    }
    async updateItemClass(args, accounts, additionalArgs) {
        const remainingAccounts = additionalArgs.permissionless
            ? [{ pubkey: accounts.parent, isWritable: false, isSigner: false }]
            : await (0, common_1.generateRemainingAccountsGivenPermissivenessToUse)({
                permissivenessToUse: args.updatePermissivenessToUse,
                tokenMint: accounts.itemMint,
                parentMint: accounts.parentMint,
                parentIndex: args.parentClassIndex,
                parent: accounts.parent,
                metadataUpdateAuthority: accounts.metadataUpdateAuthority,
                program: this.program,
            });
        convertNumsToBNs(args);
        const itemClassKey = (await (0, pda_1.getItemPDA)(accounts.itemMint, args.classIndex))[0];
        await this.program.rpc.updateItemClass(args, {
            accounts: {
                itemClass: itemClassKey,
                parent: accounts.parent || anchor_1.web3.SystemProgram.programId,
                itemMint: accounts.itemMint,
            },
            remainingAccounts: remainingAccounts.length > 0 ? remainingAccounts : undefined,
        });
        return itemClassKey;
    }
}
exports.ItemProgram = ItemProgram;
async function getItemProgram(anchorWallet, env, customRpcUrl) {
    if (customRpcUrl)
        loglevel_1.default.debug("USING CUSTOM URL", customRpcUrl);
    const solConnection = new anchor_1.web3.Connection(customRpcUrl || (0, connection_1.getCluster)(env));
    if (anchorWallet instanceof anchor_1.web3.Keypair)
        anchorWallet = new nodewallet_1.default(anchorWallet);
    const provider = new anchor_1.Provider(solConnection, anchorWallet, {
        preflightCommitment: "recent",
    });
    const idl = await anchor_1.Program.fetchIdl(programIds_1.ITEM_ID, provider);
    const program = new anchor_1.Program(idl, programIds_1.ITEM_ID, provider);
    return new ItemProgram({
        id: programIds_1.ITEM_ID,
        program,
    });
}
exports.getItemProgram = getItemProgram;
