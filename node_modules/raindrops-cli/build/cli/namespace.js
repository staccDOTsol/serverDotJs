#!/usr/bin/env ts-node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const loglevel_1 = __importDefault(require("loglevel"));
const commander_1 = require("commander");
const anchor_1 = require("@project-serum/anchor");
const utils_1 = require("./utils");
const namespace_1 = require("../contract/namespace");
const file_1 = require("../utils/file");
const pda_1 = require("../utils/pda");
(0, utils_1.programCommand)("initialize_namespace")
    .requiredOption("-cp, --config-path <string>", "JSON file with namespace settings")
    .action(async (_files, cmd) => {
    const { keypair, env, rpcUrl, configPath } = cmd.opts();
    const walletKeyPair = (0, file_1.loadWalletKey)(keypair);
    const anchorProgram = await (0, namespace_1.getNamespaceProgram)(walletKeyPair, env, rpcUrl);
    if (configPath === undefined) {
        throw new Error("The configPath is undefined");
    }
    const configString = fs.readFileSync(configPath);
    const config = JSON.parse(configString.toString());
    const whitelistedStakingMints = config.whitelistedStakingMints.map(mint => new anchor_1.web3.PublicKey(mint));
    await anchorProgram.initializeNamespace({
        desiredNamespaceArraySize: config.desiredNamespaceArraySize,
        uuid: config.uuid,
        prettyName: config.prettyName,
        permissivenessSettings: config.permissivenessSettings,
        whitelistedStakingMints: whitelistedStakingMints
    }, {
        mint: new anchor_1.web3.PublicKey(config.mint),
        metadata: new anchor_1.web3.PublicKey(config.metadata),
        masterEdition: new anchor_1.web3.PublicKey(config.masterEdition),
    });
});
(0, utils_1.programCommand)("show_namespace")
    .option("-m, --mint <string>", "Token mint associated with namespace")
    .action(async (_files, cmd) => {
    var _a, _b;
    const { keypair, env, rpcUrl, mint } = cmd.opts();
    const walletKeyPair = (0, file_1.loadWalletKey)(keypair);
    const anchorProgram = await (0, namespace_1.getNamespaceProgram)(walletKeyPair, env, rpcUrl);
    let tokenMint = new anchor_1.web3.PublicKey(mint);
    const namespaceKey = (await (0, pda_1.getNamespacePDA)(tokenMint))[0];
    const namespace = await anchorProgram.program.account.namespace.fetch(namespaceKey);
    loglevel_1.default.setLevel("info");
    loglevel_1.default.info("Namespace:", namespaceKey.toBase58());
    loglevel_1.default.info(`Namespaces: ${namespace.namespaces ? "[" : "[]"}`);
    if (namespace.namespaces) {
        namespace.namespaces.map((n) => {
            loglevel_1.default.info(`{`);
            loglevel_1.default.info(`\tnamespace: ${n.namespace.toBase58()}`);
            loglevel_1.default.info(`\tindexed: ${n.indexed}`);
            loglevel_1.default.info(`\tinherited: ${Object.keys(n.inherited).join(", ")}`);
            loglevel_1.default.info(`}`);
        });
        loglevel_1.default.info("]");
    }
    loglevel_1.default.info("Mint:", namespace.mint ? namespace.mint.toBase58() : "Not cached on object");
    loglevel_1.default.info("Metadata:", namespace.metadata ? namespace.metadata.toBase58() : "Not cached on object");
    loglevel_1.default.info("Master Edition:", namespace.masterEdition ? namespace.masterEdition.toBase58() : "Not cached on object");
    loglevel_1.default.info("UUID:", namespace.uuid ? namespace.uuid.toString() : "Not cached on object");
    loglevel_1.default.info("Pretty Name:", namespace.prettyName ? namespace.prettyName.toString() : "Not cached on object");
    loglevel_1.default.info("Artifacts Added:", namespace.artifactsAdded ? namespace.artifactsAdded.toNumber() : "Not cached on object");
    loglevel_1.default.info("Highest Page:", namespace.highestPage ? namespace.highestPage.toNumber() : "Not cached on object");
    loglevel_1.default.info("Aritfacts Cached:", namespace.artifactsCached ? namespace.artifactsCached.toNumber() : "Not cached on object");
    loglevel_1.default.info("Permissiveness Settings: {");
    loglevel_1.default.info(`\tNamespace Permissiveness: ${Object.keys(namespace.permissivenessSettings.namespacePermissiveness).join(", ")}`);
    loglevel_1.default.info(`\tItem Permissiveness: ${Object.keys(namespace.permissivenessSettings.itemPermissiveness).join(", ")}`);
    loglevel_1.default.info(`\tPlayer Permissiveness: ${Object.keys(namespace.permissivenessSettings.playerPermissiveness).join(", ")}`);
    loglevel_1.default.info(`\tMatch Permissiveness: ${Object.keys(namespace.permissivenessSettings.matchPermissiveness).join(", ")}`);
    loglevel_1.default.info(`\tMission Permissiveness: ${Object.keys(namespace.permissivenessSettings.missionPermissiveness).join(", ")}`);
    loglevel_1.default.info(`\tCache Permissiveness: ${Object.keys(namespace.permissivenessSettings.cachePermissiveness).join(", ")}`);
    loglevel_1.default.info("}");
    loglevel_1.default.info("Bump:", namespace.bump ? namespace.bump : "Not cached on object");
    loglevel_1.default.info(`Whitelist Staking Mints: [${((_a = namespace.whitelistedStakingMints) === null || _a === void 0 ? void 0 : _a.length) > 0 ? "" : "]"}`);
    if (((_b = namespace.whitelistedStakingMints) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        namespace.whitelistedStakingMints.map((wlStakingMint) => {
            loglevel_1.default.info(`\t${wlStakingMint.toBase58()}`);
        });
        loglevel_1.default.info("]");
    }
});
commander_1.program.parse(process.argv);
